<?php
/**
 * IngredientsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.spoonacular.client\com.spoonacular;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.spoonacular.client\ApiException;
use com.spoonacular.client\Configuration;
use com.spoonacular.client\HeaderSelector;
use com.spoonacular.client\ObjectSerializer;

/**
 * IngredientsApi Class Doc Comment
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IngredientsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation autocompleteIngredientSearch
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]
     */
    public function autocompleteIngredientSearch($query = null, $number = 10, $meta_information = null, $intolerances = null, $language = null)
    {
        list($response) = $this->autocompleteIngredientSearchWithHttpInfo($query, $number, $meta_information, $intolerances, $language);
        return $response;
    }

    /**
     * Operation autocompleteIngredientSearchWithHttpInfo
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteIngredientSearchWithHttpInfo($query = null, $number = 10, $meta_information = null, $intolerances = null, $language = null)
    {
        $request = $this->autocompleteIngredientSearchRequest($query, $number, $meta_information, $intolerances, $language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteIngredientSearchAsync
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteIngredientSearchAsync($query = null, $number = 10, $meta_information = null, $intolerances = null, $language = null)
    {
        return $this->autocompleteIngredientSearchAsyncWithHttpInfo($query, $number, $meta_information, $intolerances, $language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteIngredientSearchAsyncWithHttpInfo
     *
     * Autocomplete Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteIngredientSearchAsyncWithHttpInfo($query = null, $number = 10, $meta_information = null, $intolerances = null, $language = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteIngredientSearch200ResponseInner[]';
        $request = $this->autocompleteIngredientSearchRequest($query, $number, $meta_information, $intolerances, $language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteIngredientSearch'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autocompleteIngredientSearchRequest($query = null, $number = 10, $meta_information = null, $intolerances = null, $language = null)
    {
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling IngredientsApi.autocompleteIngredientSearch, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling IngredientsApi.autocompleteIngredientSearch, must be bigger than or equal to 1.');
        }


        $resourcePath = '/food/ingredients/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_information,
            'metaInformation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $intolerances,
            'intolerances', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation computeIngredientAmount
     *
     * Compute Ingredient Amount
     *
     * @param  float $id The id of the ingredient you want the amount for. (required)
     * @param  string $nutrient The target nutrient. See a list of supported nutrients. (required)
     * @param  float $target The target number of the given nutrient. (required)
     * @param  string $unit The target unit. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response
     */
    public function computeIngredientAmount($id, $nutrient, $target, $unit = null)
    {
        list($response) = $this->computeIngredientAmountWithHttpInfo($id, $nutrient, $target, $unit);
        return $response;
    }

    /**
     * Operation computeIngredientAmountWithHttpInfo
     *
     * Compute Ingredient Amount
     *
     * @param  float $id The id of the ingredient you want the amount for. (required)
     * @param  string $nutrient The target nutrient. See a list of supported nutrients. (required)
     * @param  float $target The target number of the given nutrient. (required)
     * @param  string $unit The target unit. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function computeIngredientAmountWithHttpInfo($id, $nutrient, $target, $unit = null)
    {
        $request = $this->computeIngredientAmountRequest($id, $nutrient, $target, $unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation computeIngredientAmountAsync
     *
     * Compute Ingredient Amount
     *
     * @param  float $id The id of the ingredient you want the amount for. (required)
     * @param  string $nutrient The target nutrient. See a list of supported nutrients. (required)
     * @param  float $target The target number of the given nutrient. (required)
     * @param  string $unit The target unit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeIngredientAmountAsync($id, $nutrient, $target, $unit = null)
    {
        return $this->computeIngredientAmountAsyncWithHttpInfo($id, $nutrient, $target, $unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation computeIngredientAmountAsyncWithHttpInfo
     *
     * Compute Ingredient Amount
     *
     * @param  float $id The id of the ingredient you want the amount for. (required)
     * @param  string $nutrient The target nutrient. See a list of supported nutrients. (required)
     * @param  float $target The target number of the given nutrient. (required)
     * @param  string $unit The target unit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeIngredientAmountAsyncWithHttpInfo($id, $nutrient, $target, $unit = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ComputeIngredientAmount200Response';
        $request = $this->computeIngredientAmountRequest($id, $nutrient, $target, $unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'computeIngredientAmount'
     *
     * @param  float $id The id of the ingredient you want the amount for. (required)
     * @param  string $nutrient The target nutrient. See a list of supported nutrients. (required)
     * @param  float $target The target number of the given nutrient. (required)
     * @param  string $unit The target unit. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function computeIngredientAmountRequest($id, $nutrient, $target, $unit = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling computeIngredientAmount'
            );
        }
        // verify the required parameter 'nutrient' is set
        if ($nutrient === null || (is_array($nutrient) && count($nutrient) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nutrient when calling computeIngredientAmount'
            );
        }
        // verify the required parameter 'target' is set
        if ($target === null || (is_array($target) && count($target) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target when calling computeIngredientAmount'
            );
        }

        $resourcePath = '/food/ingredients/{id}/amount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $nutrient,
            'nutrient', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unit,
            'unit', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientInformation
     *
     * Get Ingredient Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response
     */
    public function getIngredientInformation($id, $amount = null, $unit = null)
    {
        list($response) = $this->getIngredientInformationWithHttpInfo($id, $amount, $unit);
        return $response;
    }

    /**
     * Operation getIngredientInformationWithHttpInfo
     *
     * Get Ingredient Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientInformationWithHttpInfo($id, $amount = null, $unit = null)
    {
        $request = $this->getIngredientInformationRequest($id, $amount, $unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientInformationAsync
     *
     * Get Ingredient Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientInformationAsync($id, $amount = null, $unit = null)
    {
        return $this->getIngredientInformationAsyncWithHttpInfo($id, $amount, $unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientInformationAsyncWithHttpInfo
     *
     * Get Ingredient Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientInformationAsyncWithHttpInfo($id, $amount = null, $unit = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientInformation200Response';
        $request = $this->getIngredientInformationRequest($id, $amount, $unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientInformation'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  float $amount The amount of this ingredient. (optional)
     * @param  string $unit The unit for the given amount. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getIngredientInformationRequest($id, $amount = null, $unit = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getIngredientInformation'
            );
        }

        $resourcePath = '/food/ingredients/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unit,
            'unit', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientSubstitutes
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response
     */
    public function getIngredientSubstitutes($ingredient_name)
    {
        list($response) = $this->getIngredientSubstitutesWithHttpInfo($ingredient_name);
        return $response;
    }

    /**
     * Operation getIngredientSubstitutesWithHttpInfo
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientSubstitutesWithHttpInfo($ingredient_name)
    {
        $request = $this->getIngredientSubstitutesRequest($ingredient_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientSubstitutesAsync
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesAsync($ingredient_name)
    {
        return $this->getIngredientSubstitutesAsyncWithHttpInfo($ingredient_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientSubstitutesAsyncWithHttpInfo
     *
     * Get Ingredient Substitutes
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesAsyncWithHttpInfo($ingredient_name)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response';
        $request = $this->getIngredientSubstitutesRequest($ingredient_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientSubstitutes'
     *
     * @param  string $ingredient_name The name of the ingredient you want to replace. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getIngredientSubstitutesRequest($ingredient_name)
    {
        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling getIngredientSubstitutes'
            );
        }

        $resourcePath = '/food/ingredients/substitutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ingredient_name,
            'ingredientName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIngredientSubstitutesByID
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response
     */
    public function getIngredientSubstitutesByID($id)
    {
        list($response) = $this->getIngredientSubstitutesByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getIngredientSubstitutesByIDWithHttpInfo
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIngredientSubstitutesByIDWithHttpInfo($id)
    {
        $request = $this->getIngredientSubstitutesByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getIngredientSubstitutesByIDAsync
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesByIDAsync($id)
    {
        return $this->getIngredientSubstitutesByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIngredientSubstitutesByIDAsyncWithHttpInfo
     *
     * Get Ingredient Substitutes by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIngredientSubstitutesByIDAsyncWithHttpInfo($id)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetIngredientSubstitutes200Response';
        $request = $this->getIngredientSubstitutesByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIngredientSubstitutesByID'
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getIngredientSubstitutesByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getIngredientSubstitutesByID'
            );
        }

        $resourcePath = '/food/ingredients/{id}/substitutes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientSearch
     *
     * Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response
     */
    public function ingredientSearch($query = null, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = 10, $language = null)
    {
        list($response) = $this->ingredientSearchWithHttpInfo($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number, $language);
        return $response;
    }

    /**
     * Operation ingredientSearchWithHttpInfo
     *
     * Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientSearchWithHttpInfo($query = null, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = 10, $language = null)
    {
        $request = $this->ingredientSearchRequest($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number, $language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientSearchAsync
     *
     * Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientSearchAsync($query = null, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = 10, $language = null)
    {
        return $this->ingredientSearchAsyncWithHttpInfo($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number, $language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientSearchAsyncWithHttpInfo
     *
     * Ingredient Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientSearchAsyncWithHttpInfo($query = null, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = 10, $language = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\IngredientSearch200Response';
        $request = $this->ingredientSearchRequest($query, $add_children, $min_protein_percent, $max_protein_percent, $min_fat_percent, $max_fat_percent, $min_carbs_percent, $max_carbs_percent, $meta_information, $intolerances, $sort, $sort_direction, $offset, $number, $language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientSearch'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  bool $add_children Whether to add children of found foods. (optional)
     * @param  float $min_protein_percent The minimum percentage of protein the food must have (between 0 and 100). (optional)
     * @param  float $max_protein_percent The maximum percentage of protein the food can have (between 0 and 100). (optional)
     * @param  float $min_fat_percent The minimum percentage of fat the food must have (between 0 and 100). (optional)
     * @param  float $max_fat_percent The maximum percentage of fat the food can have (between 0 and 100). (optional)
     * @param  float $min_carbs_percent The minimum percentage of carbs the food must have (between 0 and 100). (optional)
     * @param  float $max_carbs_percent The maximum percentage of carbs the food can have (between 0 and 100). (optional)
     * @param  bool $meta_information Whether to return more meta information about the ingredients. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientSearchRequest($query = null, $add_children = null, $min_protein_percent = null, $max_protein_percent = null, $min_fat_percent = null, $max_fat_percent = null, $min_carbs_percent = null, $max_carbs_percent = null, $meta_information = null, $intolerances = null, $sort = null, $sort_direction = null, $offset = null, $number = 10, $language = null)
    {
        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling IngredientsApi.ingredientSearch, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling IngredientsApi.ingredientSearch, must be bigger than or equal to 0.');
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling IngredientsApi.ingredientSearch, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling IngredientsApi.ingredientSearch, must be bigger than or equal to 1.');
        }


        $resourcePath = '/food/ingredients/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_children,
            'addChildren', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein_percent,
            'minProteinPercent', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein_percent,
            'maxProteinPercent', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat_percent,
            'minFatPercent', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat_percent,
            'maxFatPercent', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs_percent,
            'minCarbsPercent', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs_percent,
            'maxCarbsPercent', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $meta_information,
            'metaInformation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $intolerances,
            'intolerances', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sortDirection', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsByIDImage
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function ingredientsByIDImage($id, $measure = null)
    {
        list($response) = $this->ingredientsByIDImageWithHttpInfo($id, $measure);
        return $response;
    }

    /**
     * Operation ingredientsByIDImageWithHttpInfo
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsByIDImageWithHttpInfo($id, $measure = null)
    {
        $request = $this->ingredientsByIDImageRequest($id, $measure);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsByIDImageAsync
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsByIDImageAsync($id, $measure = null)
    {
        return $this->ingredientsByIDImageAsyncWithHttpInfo($id, $measure)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsByIDImageAsyncWithHttpInfo
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsByIDImageAsyncWithHttpInfo($id, $measure = null)
    {
        $returnType = 'object';
        $request = $this->ingredientsByIDImageRequest($id, $measure);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsByIDImageRequest($id, $measure = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ingredientsByIDImage'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $measure,
            'measure', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mapIngredientsToGroceryProducts
     *
     * Map Ingredients to Grocery Products
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProductsRequest $map_ingredients_to_grocery_products_request map_ingredients_to_grocery_products_request (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]
     */
    public function mapIngredientsToGroceryProducts($map_ingredients_to_grocery_products_request)
    {
        list($response) = $this->mapIngredientsToGroceryProductsWithHttpInfo($map_ingredients_to_grocery_products_request);
        return $response;
    }

    /**
     * Operation mapIngredientsToGroceryProductsWithHttpInfo
     *
     * Map Ingredients to Grocery Products
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProductsRequest $map_ingredients_to_grocery_products_request (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function mapIngredientsToGroceryProductsWithHttpInfo($map_ingredients_to_grocery_products_request)
    {
        $request = $this->mapIngredientsToGroceryProductsRequest($map_ingredients_to_grocery_products_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mapIngredientsToGroceryProductsAsync
     *
     * Map Ingredients to Grocery Products
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProductsRequest $map_ingredients_to_grocery_products_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mapIngredientsToGroceryProductsAsync($map_ingredients_to_grocery_products_request)
    {
        return $this->mapIngredientsToGroceryProductsAsyncWithHttpInfo($map_ingredients_to_grocery_products_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mapIngredientsToGroceryProductsAsyncWithHttpInfo
     *
     * Map Ingredients to Grocery Products
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProductsRequest $map_ingredients_to_grocery_products_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mapIngredientsToGroceryProductsAsyncWithHttpInfo($map_ingredients_to_grocery_products_request)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProducts200ResponseInner[]';
        $request = $this->mapIngredientsToGroceryProductsRequest($map_ingredients_to_grocery_products_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mapIngredientsToGroceryProducts'
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\MapIngredientsToGroceryProductsRequest $map_ingredients_to_grocery_products_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function mapIngredientsToGroceryProductsRequest($map_ingredients_to_grocery_products_request)
    {
        // verify the required parameter 'map_ingredients_to_grocery_products_request' is set
        if ($map_ingredients_to_grocery_products_request === null || (is_array($map_ingredients_to_grocery_products_request) && count($map_ingredients_to_grocery_products_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $map_ingredients_to_grocery_products_request when calling mapIngredientsToGroceryProducts'
            );
        }

        $resourcePath = '/food/ingredients/map';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($map_ingredients_to_grocery_products_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($map_ingredients_to_grocery_products_request));
            } else {
                $httpBody = $map_ingredients_to_grocery_products_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeIngredients
     *
     * Ingredients Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeIngredients($content_type = null, $language = null, $accept = null)
    {
        list($response) = $this->visualizeIngredientsWithHttpInfo($content_type, $language, $accept);
        return $response;
    }

    /**
     * Operation visualizeIngredientsWithHttpInfo
     *
     * Ingredients Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeIngredientsWithHttpInfo($content_type = null, $language = null, $accept = null)
    {
        $request = $this->visualizeIngredientsRequest($content_type, $language, $accept);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeIngredientsAsync
     *
     * Ingredients Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeIngredientsAsync($content_type = null, $language = null, $accept = null)
    {
        return $this->visualizeIngredientsAsyncWithHttpInfo($content_type, $language, $accept)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeIngredientsAsyncWithHttpInfo
     *
     * Ingredients Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeIngredientsAsyncWithHttpInfo($content_type = null, $language = null, $accept = null)
    {
        $returnType = 'string';
        $request = $this->visualizeIngredientsRequest($content_type, $language, $accept);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeIngredients'
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeIngredientsRequest($content_type = null, $language = null, $accept = null)
    {

        $resourcePath = '/recipes/visualizeIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
