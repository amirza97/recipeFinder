<?php
/**
 * RecipesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.spoonacular.client\com.spoonacular;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.spoonacular.client\ApiException;
use com.spoonacular.client\Configuration;
use com.spoonacular.client\HeaderSelector;
use com.spoonacular.client\ObjectSerializer;

/**
 * RecipesApi Class Doc Comment
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RecipesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation analyzeARecipeSearchQuery
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response
     */
    public function analyzeARecipeSearchQuery($q)
    {
        list($response) = $this->analyzeARecipeSearchQueryWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation analyzeARecipeSearchQueryWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeARecipeSearchQueryWithHttpInfo($q)
    {
        $request = $this->analyzeARecipeSearchQueryRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeARecipeSearchQueryAsync
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsync($q)
    {
        return $this->analyzeARecipeSearchQueryAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeARecipeSearchQueryAsyncWithHttpInfo
     *
     * Analyze a Recipe Search Query
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeARecipeSearchQueryAsyncWithHttpInfo($q)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeARecipeSearchQuery200Response';
        $request = $this->analyzeARecipeSearchQueryRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeARecipeSearchQuery'
     *
     * @param  string $q The recipe search query. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function analyzeARecipeSearchQueryRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling analyzeARecipeSearchQuery'
            );
        }

        $resourcePath = '/recipes/queries/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation analyzeRecipeInstructions
     *
     * Analyze Recipe Instructions
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response
     */
    public function analyzeRecipeInstructions($content_type = null)
    {
        list($response) = $this->analyzeRecipeInstructionsWithHttpInfo($content_type);
        return $response;
    }

    /**
     * Operation analyzeRecipeInstructionsWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function analyzeRecipeInstructionsWithHttpInfo($content_type = null)
    {
        $request = $this->analyzeRecipeInstructionsRequest($content_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation analyzeRecipeInstructionsAsync
     *
     * Analyze Recipe Instructions
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsync($content_type = null)
    {
        return $this->analyzeRecipeInstructionsAsyncWithHttpInfo($content_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeRecipeInstructionsAsyncWithHttpInfo
     *
     * Analyze Recipe Instructions
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function analyzeRecipeInstructionsAsyncWithHttpInfo($content_type = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AnalyzeRecipeInstructions200Response';
        $request = $this->analyzeRecipeInstructionsRequest($content_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeRecipeInstructions'
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function analyzeRecipeInstructionsRequest($content_type = null)
    {

        $resourcePath = '/recipes/analyzeInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autocompleteRecipeSearch
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]
     */
    public function autocompleteRecipeSearch($query = null, $number = 10)
    {
        list($response) = $this->autocompleteRecipeSearchWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation autocompleteRecipeSearchWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteRecipeSearchWithHttpInfo($query = null, $number = 10)
    {
        $request = $this->autocompleteRecipeSearchRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteRecipeSearchAsync
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsync($query = null, $number = 10)
    {
        return $this->autocompleteRecipeSearchAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteRecipeSearchAsyncWithHttpInfo
     *
     * Autocomplete Recipe Search
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteRecipeSearchAsyncWithHttpInfo($query = null, $number = 10)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\AutocompleteRecipeSearch200ResponseInner[]';
        $request = $this->autocompleteRecipeSearchRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteRecipeSearch'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autocompleteRecipeSearchRequest($query = null, $number = 10)
    {
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.autocompleteRecipeSearch, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.autocompleteRecipeSearch, must be bigger than or equal to 1.');
        }


        $resourcePath = '/recipes/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation classifyCuisine
     *
     * Classify Cuisine
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response
     */
    public function classifyCuisine($content_type = null)
    {
        list($response) = $this->classifyCuisineWithHttpInfo($content_type);
        return $response;
    }

    /**
     * Operation classifyCuisineWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function classifyCuisineWithHttpInfo($content_type = null)
    {
        $request = $this->classifyCuisineRequest($content_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation classifyCuisineAsync
     *
     * Classify Cuisine
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsync($content_type = null)
    {
        return $this->classifyCuisineAsyncWithHttpInfo($content_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation classifyCuisineAsyncWithHttpInfo
     *
     * Classify Cuisine
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyCuisineAsyncWithHttpInfo($content_type = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ClassifyCuisine200Response';
        $request = $this->classifyCuisineRequest($content_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'classifyCuisine'
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function classifyCuisineRequest($content_type = null)
    {

        $resourcePath = '/recipes/cuisine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation computeGlycemicLoad
     *
     * Compute Glycemic Load
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoadRequest $compute_glycemic_load_request compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response
     */
    public function computeGlycemicLoad($compute_glycemic_load_request, $language = null)
    {
        list($response) = $this->computeGlycemicLoadWithHttpInfo($compute_glycemic_load_request, $language);
        return $response;
    }

    /**
     * Operation computeGlycemicLoadWithHttpInfo
     *
     * Compute Glycemic Load
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function computeGlycemicLoadWithHttpInfo($compute_glycemic_load_request, $language = null)
    {
        $request = $this->computeGlycemicLoadRequest($compute_glycemic_load_request, $language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation computeGlycemicLoadAsync
     *
     * Compute Glycemic Load
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeGlycemicLoadAsync($compute_glycemic_load_request, $language = null)
    {
        return $this->computeGlycemicLoadAsyncWithHttpInfo($compute_glycemic_load_request, $language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation computeGlycemicLoadAsyncWithHttpInfo
     *
     * Compute Glycemic Load
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function computeGlycemicLoadAsyncWithHttpInfo($compute_glycemic_load_request, $language = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoad200Response';
        $request = $this->computeGlycemicLoadRequest($compute_glycemic_load_request, $language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'computeGlycemicLoad'
     *
     * @param  \com.spoonacular.client\com.spoonacular.client.model\ComputeGlycemicLoadRequest $compute_glycemic_load_request (required)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function computeGlycemicLoadRequest($compute_glycemic_load_request, $language = null)
    {
        // verify the required parameter 'compute_glycemic_load_request' is set
        if ($compute_glycemic_load_request === null || (is_array($compute_glycemic_load_request) && count($compute_glycemic_load_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $compute_glycemic_load_request when calling computeGlycemicLoad'
            );
        }

        $resourcePath = '/food/ingredients/glycemicLoad';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($compute_glycemic_load_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($compute_glycemic_load_request));
            } else {
                $httpBody = $compute_glycemic_load_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertAmounts
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response
     */
    public function convertAmounts($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        list($response) = $this->convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit);
        return $response;
    }

    /**
     * Operation convertAmountsWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function convertAmountsWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation convertAmountsAsync
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsync($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        return $this->convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertAmountsAsyncWithHttpInfo
     *
     * Convert Amounts
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertAmountsAsyncWithHttpInfo($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ConvertAmounts200Response';
        $request = $this->convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertAmounts'
     *
     * @param  string $ingredient_name The ingredient which you want to convert. (required)
     * @param  float $source_amount The amount from which you want to convert, e.g. the 2.5 in \&quot;2.5 cups of flour to grams\&quot;. (required)
     * @param  string $source_unit The unit from which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     * @param  string $target_unit The unit to which you want to convert, e.g. the grams in \&quot;2.5 cups of flour to grams\&quot;. You can also use \&quot;piece\&quot;, e.g. \&quot;3.4 oz tomatoes to piece\&quot; (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function convertAmountsRequest($ingredient_name, $source_amount, $source_unit, $target_unit)
    {
        // verify the required parameter 'ingredient_name' is set
        if ($ingredient_name === null || (is_array($ingredient_name) && count($ingredient_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ingredient_name when calling convertAmounts'
            );
        }
        // verify the required parameter 'source_amount' is set
        if ($source_amount === null || (is_array($source_amount) && count($source_amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_amount when calling convertAmounts'
            );
        }
        // verify the required parameter 'source_unit' is set
        if ($source_unit === null || (is_array($source_unit) && count($source_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_unit when calling convertAmounts'
            );
        }
        // verify the required parameter 'target_unit' is set
        if ($target_unit === null || (is_array($target_unit) && count($target_unit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_unit when calling convertAmounts'
            );
        }

        $resourcePath = '/recipes/convert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ingredient_name,
            'ingredientName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $source_amount,
            'sourceAmount', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $source_unit,
            'sourceUnit', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_unit,
            'targetUnit', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRecipeCard
     *
     * Create Recipe Card
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response
     */
    public function createRecipeCard($content_type = null)
    {
        list($response) = $this->createRecipeCardWithHttpInfo($content_type);
        return $response;
    }

    /**
     * Operation createRecipeCardWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRecipeCardWithHttpInfo($content_type = null)
    {
        $request = $this->createRecipeCardRequest($content_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRecipeCardAsync
     *
     * Create Recipe Card
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsync($content_type = null)
    {
        return $this->createRecipeCardAsyncWithHttpInfo($content_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRecipeCardAsyncWithHttpInfo
     *
     * Create Recipe Card
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRecipeCardAsyncWithHttpInfo($content_type = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\CreateRecipeCard200Response';
        $request = $this->createRecipeCardRequest($content_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRecipeCard'
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRecipeCardRequest($content_type = null)
    {

        $resourcePath = '/recipes/visualizeRecipe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation equipmentByIDImage
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function equipmentByIDImage($id)
    {
        list($response) = $this->equipmentByIDImageWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation equipmentByIDImageWithHttpInfo
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function equipmentByIDImageWithHttpInfo($id)
    {
        $request = $this->equipmentByIDImageRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation equipmentByIDImageAsync
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipmentByIDImageAsync($id)
    {
        return $this->equipmentByIDImageAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation equipmentByIDImageAsyncWithHttpInfo
     *
     * Equipment by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function equipmentByIDImageAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->equipmentByIDImageRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'equipmentByIDImage'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function equipmentByIDImageRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling equipmentByIDImage'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation extractRecipeFromWebsite
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response
     */
    public function extractRecipeFromWebsite($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false)
    {
        list($response) = $this->extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction, $analyze, $include_nutrition, $include_taste);
        return $response;
    }

    /**
     * Operation extractRecipeFromWebsiteWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function extractRecipeFromWebsiteWithHttpInfo($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false)
    {
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction, $analyze, $include_nutrition, $include_taste);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation extractRecipeFromWebsiteAsync
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsync($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false)
    {
        return $this->extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction, $analyze, $include_nutrition, $include_taste)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation extractRecipeFromWebsiteAsyncWithHttpInfo
     *
     * Extract Recipe from Website
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function extractRecipeFromWebsiteAsyncWithHttpInfo($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response';
        $request = $this->extractRecipeFromWebsiteRequest($url, $force_extraction, $analyze, $include_nutrition, $include_taste);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'extractRecipeFromWebsite'
     *
     * @param  string $url The URL of the recipe page. (required)
     * @param  bool $force_extraction If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower. (optional)
     * @param  bool $analyze If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more. (optional)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     * @param  bool $include_taste Whether taste data should be added to correctly parsed ingredients. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function extractRecipeFromWebsiteRequest($url, $force_extraction = null, $analyze = null, $include_nutrition = false, $include_taste = false)
    {
        // verify the required parameter 'url' is set
        if ($url === null || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $url when calling extractRecipeFromWebsite'
            );
        }

        $resourcePath = '/recipes/extract';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_extraction,
            'forceExtraction', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $analyze,
            'analyze', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_taste,
            'includeTaste', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnalyzedRecipeInstructions
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response
     */
    public function getAnalyzedRecipeInstructions($id, $step_breakdown = null)
    {
        list($response) = $this->getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown);
        return $response;
    }

    /**
     * Operation getAnalyzedRecipeInstructionsWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnalyzedRecipeInstructionsWithHttpInfo($id, $step_breakdown = null)
    {
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsync
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsync($id, $step_breakdown = null)
    {
        return $this->getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnalyzedRecipeInstructionsAsyncWithHttpInfo
     *
     * Get Analyzed Recipe Instructions
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyzedRecipeInstructionsAsyncWithHttpInfo($id, $step_breakdown = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetAnalyzedRecipeInstructions200Response';
        $request = $this->getAnalyzedRecipeInstructionsRequest($id, $step_breakdown);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnalyzedRecipeInstructions'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $step_breakdown Whether to break down the recipe steps even more. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnalyzedRecipeInstructionsRequest($id, $step_breakdown = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAnalyzedRecipeInstructions'
            );
        }

        $resourcePath = '/recipes/{id}/analyzedInstructions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $step_breakdown,
            'stepBreakdown', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomRecipes
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response
     */
    public function getRandomRecipes($limit_license = true, $tags = null, $number = 10)
    {
        list($response) = $this->getRandomRecipesWithHttpInfo($limit_license, $tags, $number);
        return $response;
    }

    /**
     * Operation getRandomRecipesWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomRecipesWithHttpInfo($limit_license = true, $tags = null, $number = 10)
    {
        $request = $this->getRandomRecipesRequest($limit_license, $tags, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomRecipesAsync
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsync($limit_license = true, $tags = null, $number = 10)
    {
        return $this->getRandomRecipesAsyncWithHttpInfo($limit_license, $tags, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomRecipesAsyncWithHttpInfo
     *
     * Get Random Recipes
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomRecipesAsyncWithHttpInfo($limit_license = true, $tags = null, $number = 10)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRandomRecipes200Response';
        $request = $this->getRandomRecipesRequest($limit_license, $tags, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomRecipes'
     *
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRandomRecipesRequest($limit_license = true, $tags = null, $number = 10)
    {
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getRandomRecipes, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getRandomRecipes, must be bigger than or equal to 1.');
        }


        $resourcePath = '/recipes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeEquipmentByID
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response
     */
    public function getRecipeEquipmentByID($id)
    {
        list($response) = $this->getRecipeEquipmentByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeEquipmentByIDWithHttpInfo
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeEquipmentByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeEquipmentByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeEquipmentByIDAsync
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsync($id)
    {
        return $this->getRecipeEquipmentByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Equipment by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeEquipmentByIDAsyncWithHttpInfo($id)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeEquipmentByID200Response';
        $request = $this->getRecipeEquipmentByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeEquipmentByID'
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeEquipmentByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeEquipmentByID'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformation
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response
     */
    public function getRecipeInformation($id, $include_nutrition = false)
    {
        list($response) = $this->getRecipeInformationWithHttpInfo($id, $include_nutrition);
        return $response;
    }

    /**
     * Operation getRecipeInformationWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationWithHttpInfo($id, $include_nutrition = false)
    {
        $request = $this->getRecipeInformationRequest($id, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationAsync
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsync($id, $include_nutrition = false)
    {
        return $this->getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationAsyncWithHttpInfo
     *
     * Get Recipe Information
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationAsyncWithHttpInfo($id, $include_nutrition = false)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformation200Response';
        $request = $this->getRecipeInformationRequest($id, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformation'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeInformationRequest($id, $include_nutrition = false)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeInformation'
            );
        }

        $resourcePath = '/recipes/{id}/information';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeInformationBulk
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]
     */
    public function getRecipeInformationBulk($ids, $include_nutrition = false)
    {
        list($response) = $this->getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition);
        return $response;
    }

    /**
     * Operation getRecipeInformationBulkWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeInformationBulkWithHttpInfo($ids, $include_nutrition = false)
    {
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeInformationBulkAsync
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsync($ids, $include_nutrition = false)
    {
        return $this->getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeInformationBulkAsyncWithHttpInfo
     *
     * Get Recipe Information Bulk
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeInformationBulkAsyncWithHttpInfo($ids, $include_nutrition = false)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeInformationBulk200ResponseInner[]';
        $request = $this->getRecipeInformationBulkRequest($ids, $include_nutrition);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeInformationBulk'
     *
     * @param  string $ids A comma-separated list of recipe ids. (required)
     * @param  bool $include_nutrition Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeInformationBulkRequest($ids, $include_nutrition = false)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getRecipeInformationBulk'
            );
        }

        $resourcePath = '/recipes/informationBulk';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_nutrition,
            'includeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeIngredientsByID
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response
     */
    public function getRecipeIngredientsByID($id)
    {
        list($response) = $this->getRecipeIngredientsByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeIngredientsByIDWithHttpInfo
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeIngredientsByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeIngredientsByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeIngredientsByIDAsync
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsync($id)
    {
        return $this->getRecipeIngredientsByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Ingredients by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeIngredientsByIDAsyncWithHttpInfo($id)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeIngredientsByID200Response';
        $request = $this->getRecipeIngredientsByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeIngredientsByID'
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeIngredientsByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeIngredientsByID'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeNutritionWidgetByID
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response
     */
    public function getRecipeNutritionWidgetByID($id)
    {
        list($response) = $this->getRecipeNutritionWidgetByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipeNutritionWidgetByIDWithHttpInfo
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeNutritionWidgetByIDWithHttpInfo($id)
    {
        $request = $this->getRecipeNutritionWidgetByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeNutritionWidgetByIDAsync
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionWidgetByIDAsync($id)
    {
        return $this->getRecipeNutritionWidgetByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeNutritionWidgetByIDAsyncWithHttpInfo
     *
     * Nutrition by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeNutritionWidgetByIDAsyncWithHttpInfo($id)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeNutritionWidgetByID200Response';
        $request = $this->getRecipeNutritionWidgetByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeNutritionWidgetByID'
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeNutritionWidgetByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeNutritionWidgetByID'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipePriceBreakdownByID
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response
     */
    public function getRecipePriceBreakdownByID($id)
    {
        list($response) = $this->getRecipePriceBreakdownByIDWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRecipePriceBreakdownByIDWithHttpInfo
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipePriceBreakdownByIDWithHttpInfo($id)
    {
        $request = $this->getRecipePriceBreakdownByIDRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsync
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsync($id)
    {
        return $this->getRecipePriceBreakdownByIDAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Price Breakdown by ID
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipePriceBreakdownByIDAsyncWithHttpInfo($id)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipePriceBreakdownByID200Response';
        $request = $this->getRecipePriceBreakdownByIDRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipePriceBreakdownByID'
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipePriceBreakdownByIDRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipePriceBreakdownByID'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecipeTasteByID
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response
     */
    public function getRecipeTasteByID($id, $normalize = true)
    {
        list($response) = $this->getRecipeTasteByIDWithHttpInfo($id, $normalize);
        return $response;
    }

    /**
     * Operation getRecipeTasteByIDWithHttpInfo
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecipeTasteByIDWithHttpInfo($id, $normalize = true)
    {
        $request = $this->getRecipeTasteByIDRequest($id, $normalize);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRecipeTasteByIDAsync
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeTasteByIDAsync($id, $normalize = true)
    {
        return $this->getRecipeTasteByIDAsyncWithHttpInfo($id, $normalize)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecipeTasteByIDAsyncWithHttpInfo
     *
     * Taste by ID
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecipeTasteByIDAsyncWithHttpInfo($id, $normalize = true)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRecipeTasteByID200Response';
        $request = $this->getRecipeTasteByIDRequest($id, $normalize);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecipeTasteByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecipeTasteByIDRequest($id, $normalize = true)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRecipeTasteByID'
            );
        }

        $resourcePath = '/recipes/{id}/tasteWidget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSimilarRecipes
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]
     */
    public function getSimilarRecipes($id, $number = 10, $limit_license = true)
    {
        list($response) = $this->getSimilarRecipesWithHttpInfo($id, $number, $limit_license);
        return $response;
    }

    /**
     * Operation getSimilarRecipesWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSimilarRecipesWithHttpInfo($id, $number = 10, $limit_license = true)
    {
        $request = $this->getSimilarRecipesRequest($id, $number, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSimilarRecipesAsync
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsync($id, $number = 10, $limit_license = true)
    {
        return $this->getSimilarRecipesAsyncWithHttpInfo($id, $number, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSimilarRecipesAsyncWithHttpInfo
     *
     * Get Similar Recipes
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSimilarRecipesAsyncWithHttpInfo($id, $number = 10, $limit_license = true)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetSimilarRecipes200ResponseInner[]';
        $request = $this->getSimilarRecipesRequest($id, $number, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSimilarRecipes'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSimilarRecipesRequest($id, $number = 10, $limit_license = true)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getSimilarRecipes'
            );
        }
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getSimilarRecipes, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.getSimilarRecipes, must be bigger than or equal to 1.');
        }


        $resourcePath = '/recipes/{id}/similar';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation guessNutritionByDishName
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response
     */
    public function guessNutritionByDishName($title)
    {
        list($response) = $this->guessNutritionByDishNameWithHttpInfo($title);
        return $response;
    }

    /**
     * Operation guessNutritionByDishNameWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function guessNutritionByDishNameWithHttpInfo($title)
    {
        $request = $this->guessNutritionByDishNameRequest($title);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation guessNutritionByDishNameAsync
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsync($title)
    {
        return $this->guessNutritionByDishNameAsyncWithHttpInfo($title)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation guessNutritionByDishNameAsyncWithHttpInfo
     *
     * Guess Nutrition by Dish Name
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function guessNutritionByDishNameAsyncWithHttpInfo($title)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GuessNutritionByDishName200Response';
        $request = $this->guessNutritionByDishNameRequest($title);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'guessNutritionByDishName'
     *
     * @param  string $title The title of the dish. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function guessNutritionByDishNameRequest($title)
    {
        // verify the required parameter 'title' is set
        if ($title === null || (is_array($title) && count($title) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $title when calling guessNutritionByDishName'
            );
        }

        $resourcePath = '/recipes/guessNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title,
            'title', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ingredientsByIDImage
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function ingredientsByIDImage($id, $measure = null)
    {
        list($response) = $this->ingredientsByIDImageWithHttpInfo($id, $measure);
        return $response;
    }

    /**
     * Operation ingredientsByIDImageWithHttpInfo
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function ingredientsByIDImageWithHttpInfo($id, $measure = null)
    {
        $request = $this->ingredientsByIDImageRequest($id, $measure);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ingredientsByIDImageAsync
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsByIDImageAsync($id, $measure = null)
    {
        return $this->ingredientsByIDImageAsyncWithHttpInfo($id, $measure)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ingredientsByIDImageAsyncWithHttpInfo
     *
     * Ingredients by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ingredientsByIDImageAsyncWithHttpInfo($id, $measure = null)
    {
        $returnType = 'object';
        $request = $this->ingredientsByIDImageRequest($id, $measure);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ingredientsByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ingredientsByIDImageRequest($id, $measure = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ingredientsByIDImage'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $measure,
            'measure', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseIngredients
     *
     * Parse Ingredients
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]
     */
    public function parseIngredients($content_type = null, $language = null)
    {
        list($response) = $this->parseIngredientsWithHttpInfo($content_type, $language);
        return $response;
    }

    /**
     * Operation parseIngredientsWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function parseIngredientsWithHttpInfo($content_type = null, $language = null)
    {
        $request = $this->parseIngredientsRequest($content_type, $language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseIngredientsAsync
     *
     * Parse Ingredients
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsync($content_type = null, $language = null)
    {
        return $this->parseIngredientsAsyncWithHttpInfo($content_type, $language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseIngredientsAsyncWithHttpInfo
     *
     * Parse Ingredients
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseIngredientsAsyncWithHttpInfo($content_type = null, $language = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ParseIngredients200ResponseInner[]';
        $request = $this->parseIngredientsRequest($content_type, $language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseIngredients'
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseIngredientsRequest($content_type = null, $language = null)
    {

        $resourcePath = '/recipes/parseIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation priceBreakdownByIDImage
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function priceBreakdownByIDImage($id)
    {
        list($response) = $this->priceBreakdownByIDImageWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation priceBreakdownByIDImageWithHttpInfo
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function priceBreakdownByIDImageWithHttpInfo($id)
    {
        $request = $this->priceBreakdownByIDImageRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation priceBreakdownByIDImageAsync
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceBreakdownByIDImageAsync($id)
    {
        return $this->priceBreakdownByIDImageAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation priceBreakdownByIDImageAsyncWithHttpInfo
     *
     * Price Breakdown by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function priceBreakdownByIDImageAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->priceBreakdownByIDImageRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'priceBreakdownByIDImage'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function priceBreakdownByIDImageRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling priceBreakdownByIDImage'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation quickAnswer
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response
     */
    public function quickAnswer($q)
    {
        list($response) = $this->quickAnswerWithHttpInfo($q);
        return $response;
    }

    /**
     * Operation quickAnswerWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function quickAnswerWithHttpInfo($q)
    {
        $request = $this->quickAnswerRequest($q);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation quickAnswerAsync
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsync($q)
    {
        return $this->quickAnswerAsyncWithHttpInfo($q)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation quickAnswerAsyncWithHttpInfo
     *
     * Quick Answer
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function quickAnswerAsyncWithHttpInfo($q)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\QuickAnswer200Response';
        $request = $this->quickAnswerRequest($q);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'quickAnswer'
     *
     * @param  string $q The nutrition related question. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function quickAnswerRequest($q)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling quickAnswer'
            );
        }

        $resourcePath = '/recipes/quickAnswer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $q,
            'q', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeNutritionByIDImage
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function recipeNutritionByIDImage($id)
    {
        list($response) = $this->recipeNutritionByIDImageWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation recipeNutritionByIDImageWithHttpInfo
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeNutritionByIDImageWithHttpInfo($id)
    {
        $request = $this->recipeNutritionByIDImageRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeNutritionByIDImageAsync
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionByIDImageAsync($id)
    {
        return $this->recipeNutritionByIDImageAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeNutritionByIDImageAsyncWithHttpInfo
     *
     * Recipe Nutrition by ID Image
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionByIDImageAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->recipeNutritionByIDImageRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeNutritionByIDImage'
     *
     * @param  float $id The recipe id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeNutritionByIDImageRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeNutritionByIDImage'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeNutritionLabelImage
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function recipeNutritionLabelImage($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        list($response) = $this->recipeNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients);
        return $response;
    }

    /**
     * Operation recipeNutritionLabelImageWithHttpInfo
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeNutritionLabelImageWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        $request = $this->recipeNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeNutritionLabelImageAsync
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelImageAsync($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        return $this->recipeNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients, $show_zero_values, $show_ingredients)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeNutritionLabelImageAsyncWithHttpInfo
     *
     * Recipe Nutrition Label Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelImageAsyncWithHttpInfo($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        $returnType = 'object';
        $request = $this->recipeNutritionLabelImageRequest($id, $show_optional_nutrients, $show_zero_values, $show_ingredients);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeNutritionLabelImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeNutritionLabelImageRequest($id, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeNutritionLabelImage'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionLabel.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeNutritionLabelWidget
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function recipeNutritionLabelWidget($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        list($response) = $this->recipeNutritionLabelWidgetWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients);
        return $response;
    }

    /**
     * Operation recipeNutritionLabelWidgetWithHttpInfo
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeNutritionLabelWidgetWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        $request = $this->recipeNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeNutritionLabelWidgetAsync
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelWidgetAsync($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        return $this->recipeNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeNutritionLabelWidgetAsyncWithHttpInfo
     *
     * Recipe Nutrition Label Widget
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeNutritionLabelWidgetAsyncWithHttpInfo($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        $returnType = 'string';
        $request = $this->recipeNutritionLabelWidgetRequest($id, $default_css, $show_optional_nutrients, $show_zero_values, $show_ingredients);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeNutritionLabelWidget'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  bool $show_optional_nutrients Whether to show optional nutrients. (optional)
     * @param  bool $show_zero_values Whether to show zero values. (optional)
     * @param  bool $show_ingredients Whether to show a list of ingredients. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeNutritionLabelWidgetRequest($id, $default_css = true, $show_optional_nutrients = null, $show_zero_values = null, $show_ingredients = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeNutritionLabelWidget'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionLabel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_optional_nutrients,
            'showOptionalNutrients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_zero_values,
            'showZeroValues', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_ingredients,
            'showIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recipeTasteByIDImage
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function recipeTasteByIDImage($id, $normalize = null, $rgb = null)
    {
        list($response) = $this->recipeTasteByIDImageWithHttpInfo($id, $normalize, $rgb);
        return $response;
    }

    /**
     * Operation recipeTasteByIDImageWithHttpInfo
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function recipeTasteByIDImageWithHttpInfo($id, $normalize = null, $rgb = null)
    {
        $request = $this->recipeTasteByIDImageRequest($id, $normalize, $rgb);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recipeTasteByIDImageAsync
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeTasteByIDImageAsync($id, $normalize = null, $rgb = null)
    {
        return $this->recipeTasteByIDImageAsyncWithHttpInfo($id, $normalize, $rgb)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recipeTasteByIDImageAsyncWithHttpInfo
     *
     * Recipe Taste by ID Image
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recipeTasteByIDImageAsyncWithHttpInfo($id, $normalize = null, $rgb = null)
    {
        $returnType = 'object';
        $request = $this->recipeTasteByIDImageRequest($id, $normalize, $rgb);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recipeTasteByIDImage'
     *
     * @param  float $id The recipe id. (required)
     * @param  bool $normalize Normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function recipeTasteByIDImageRequest($id, $normalize = null, $rgb = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling recipeTasteByIDImage'
            );
        }

        $resourcePath = '/recipes/{id}/tasteWidget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rgb,
            'rgb', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/png'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipes
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response
     */
    public function searchRecipes($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true)
    {
        list($response) = $this->searchRecipesWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);
        return $response;
    }

    /**
     * Operation searchRecipesWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesWithHttpInfo($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true)
    {
        $request = $this->searchRecipesRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesAsync
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsync($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true)
    {
        return $this->searchRecipesAsyncWithHttpInfo($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesAsyncWithHttpInfo
     *
     * Search Recipes
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesAsyncWithHttpInfo($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipes200Response';
        $request = $this->searchRecipesRequest($query, $cuisine, $exclude_cuisine, $diet, $intolerances, $equipment, $include_ingredients, $exclude_ingredients, $type, $instructions_required, $fill_ingredients, $add_recipe_information, $add_recipe_nutrition, $author, $tags, $recipe_box_id, $title_match, $max_ready_time, $ignore_pantry, $sort, $sort_direction, $min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipes'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as &#39;OR&#39;). See a full list of supported cuisines. (optional)
     * @param  string $exclude_cuisine The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as &#39;AND&#39;). See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $intolerances A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances. (optional)
     * @param  string $equipment The equipment required. Multiple values will be interpreted as &#39;or&#39;. For example, value could be \&quot;blender, frying pan, bowl\&quot;. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that should/must be used in the recipes. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  string $type The type of recipe. See a full list of supported meal types. (optional)
     * @param  bool $instructions_required Whether the recipes must have instructions. (optional)
     * @param  bool $fill_ingredients Add information about the ingredients and whether they are used or missing in relation to the query. (optional)
     * @param  bool $add_recipe_information If set to true, you get more information about the recipes returned. (optional)
     * @param  bool $add_recipe_nutrition If set to true, you get nutritional information about each recipes returned. (optional)
     * @param  string $author The username of the recipe author. (optional)
     * @param  string $tags The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have. (optional)
     * @param  float $recipe_box_id The id of the recipe box to which the search should be limited to. (optional)
     * @param  string $title_match Enter text that must be found in the title of the recipes. (optional)
     * @param  float $max_ready_time The maximum time in minutes it should take to prepare and cook the recipe. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     * @param  string $sort The strategy to sort recipes by. See a full list of supported sorting options. (optional)
     * @param  string $sort_direction The direction in which to sort. Must be either &#39;asc&#39; (ascending) or &#39;desc&#39; (descending). (optional)
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRecipesRequest($query = null, $cuisine = null, $exclude_cuisine = null, $diet = null, $intolerances = null, $equipment = null, $include_ingredients = null, $exclude_ingredients = null, $type = null, $instructions_required = null, $fill_ingredients = null, $add_recipe_information = null, $add_recipe_nutrition = null, $author = null, $tags = null, $recipe_box_id = null, $title_match = null, $max_ready_time = null, $ignore_pantry = false, $sort = null, $sort_direction = null, $min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $limit_license = true)
    {
        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipes, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipes, must be bigger than or equal to 0.');
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipes, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipes, must be bigger than or equal to 1.');
        }


        $resourcePath = '/recipes/complexSearch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cuisine,
            'cuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_cuisine,
            'excludeCuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $diet,
            'diet', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $intolerances,
            'intolerances', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $equipment,
            'equipment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_ingredients,
            'includeIngredients', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_ingredients,
            'excludeIngredients', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $instructions_required,
            'instructionsRequired', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill_ingredients,
            'fillIngredients', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_recipe_information,
            'addRecipeInformation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $add_recipe_nutrition,
            'addRecipeNutrition', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $author,
            'author', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $recipe_box_id,
            'recipeBoxId', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $title_match,
            'titleMatch', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ready_time,
            'maxReadyTime', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_pantry,
            'ignorePantry', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sortDirection', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs,
            'minCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs,
            'maxCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein,
            'minProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein,
            'maxProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calories,
            'minCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calories,
            'maxCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat,
            'minFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat,
            'maxFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_alcohol,
            'minAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_alcohol,
            'maxAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_caffeine,
            'minCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_caffeine,
            'maxCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_copper,
            'minCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_copper,
            'maxCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calcium,
            'minCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calcium,
            'maxCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_choline,
            'minCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_choline,
            'maxCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_cholesterol,
            'minCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_cholesterol,
            'maxCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fluoride,
            'minFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fluoride,
            'maxFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_saturated_fat,
            'minSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_saturated_fat,
            'maxSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_a,
            'minVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_a,
            'maxVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_c,
            'minVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_c,
            'maxVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_d,
            'minVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_d,
            'maxVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_e,
            'minVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_e,
            'maxVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_k,
            'minVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_k,
            'maxVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b1,
            'minVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b1,
            'maxVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b2,
            'minVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b2,
            'maxVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b5,
            'minVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b5,
            'maxVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b3,
            'minVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b3,
            'maxVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b6,
            'minVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b6,
            'maxVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b12,
            'minVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b12,
            'maxVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fiber,
            'minFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fiber,
            'maxFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folate,
            'minFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folate,
            'maxFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folic_acid,
            'minFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folic_acid,
            'maxFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iodine,
            'minIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iodine,
            'maxIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iron,
            'minIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iron,
            'maxIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_magnesium,
            'minMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_magnesium,
            'maxMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_manganese,
            'minManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_manganese,
            'maxManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_phosphorus,
            'minPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_phosphorus,
            'maxPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_potassium,
            'minPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_potassium,
            'maxPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_selenium,
            'minSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_selenium,
            'maxSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sodium,
            'minSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sodium,
            'maxSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sugar,
            'minSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sugar,
            'maxSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_zinc,
            'minZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_zinc,
            'maxZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByIngredients
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]
     */
    public function searchRecipesByIngredients($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false)
    {
        list($response) = $this->searchRecipesByIngredientsWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry);
        return $response;
    }

    /**
     * Operation searchRecipesByIngredientsWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByIngredientsWithHttpInfo($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false)
    {
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByIngredientsAsync
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsync($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false)
    {
        return $this->searchRecipesByIngredientsAsyncWithHttpInfo($ingredients, $number, $limit_license, $ranking, $ignore_pantry)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByIngredientsAsyncWithHttpInfo
     *
     * Search Recipes by Ingredients
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByIngredientsAsyncWithHttpInfo($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByIngredients200ResponseInner[]';
        $request = $this->searchRecipesByIngredientsRequest($ingredients, $number, $limit_license, $ranking, $ignore_pantry);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByIngredients'
     *
     * @param  string $ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     * @param  float $ranking Whether to maximize used ingredients (1) or minimize missing ingredients (2) first. (optional)
     * @param  bool $ignore_pantry Whether to ignore typical pantry items, such as water, salt, flour, etc. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRecipesByIngredientsRequest($ingredients = null, $number = 10, $limit_license = true, $ranking = null, $ignore_pantry = false)
    {
        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByIngredients, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByIngredients, must be bigger than or equal to 1.');
        }


        $resourcePath = '/recipes/findByIngredients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ingredients,
            'ingredients', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ranking,
            'ranking', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ignore_pantry,
            'ignorePantry', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchRecipesByNutrients
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]
     */
    public function searchRecipesByNutrients($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true)
    {
        list($response) = $this->searchRecipesByNutrientsWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);
        return $response;
    }

    /**
     * Operation searchRecipesByNutrientsWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchRecipesByNutrientsWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true)
    {
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchRecipesByNutrientsAsync
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsync($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true)
    {
        return $this->searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchRecipesByNutrientsAsyncWithHttpInfo
     *
     * Search Recipes by Nutrients
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchRecipesByNutrientsAsyncWithHttpInfo($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchRecipesByNutrients200ResponseInner[]';
        $request = $this->searchRecipesByNutrientsRequest($min_carbs, $max_carbs, $min_protein, $max_protein, $min_calories, $max_calories, $min_fat, $max_fat, $min_alcohol, $max_alcohol, $min_caffeine, $max_caffeine, $min_copper, $max_copper, $min_calcium, $max_calcium, $min_choline, $max_choline, $min_cholesterol, $max_cholesterol, $min_fluoride, $max_fluoride, $min_saturated_fat, $max_saturated_fat, $min_vitamin_a, $max_vitamin_a, $min_vitamin_c, $max_vitamin_c, $min_vitamin_d, $max_vitamin_d, $min_vitamin_e, $max_vitamin_e, $min_vitamin_k, $max_vitamin_k, $min_vitamin_b1, $max_vitamin_b1, $min_vitamin_b2, $max_vitamin_b2, $min_vitamin_b5, $max_vitamin_b5, $min_vitamin_b3, $max_vitamin_b3, $min_vitamin_b6, $max_vitamin_b6, $min_vitamin_b12, $max_vitamin_b12, $min_fiber, $max_fiber, $min_folate, $max_folate, $min_folic_acid, $max_folic_acid, $min_iodine, $max_iodine, $min_iron, $max_iron, $min_magnesium, $max_magnesium, $min_manganese, $max_manganese, $min_phosphorus, $max_phosphorus, $min_potassium, $max_potassium, $min_selenium, $max_selenium, $min_sodium, $max_sodium, $min_sugar, $max_sugar, $min_zinc, $max_zinc, $offset, $number, $random, $limit_license);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchRecipesByNutrients'
     *
     * @param  float $min_carbs The minimum amount of carbohydrates in grams the recipe must have. (optional)
     * @param  float $max_carbs The maximum amount of carbohydrates in grams the recipe can have. (optional)
     * @param  float $min_protein The minimum amount of protein in grams the recipe must have. (optional)
     * @param  float $max_protein The maximum amount of protein in grams the recipe can have. (optional)
     * @param  float $min_calories The minimum amount of calories the recipe must have. (optional)
     * @param  float $max_calories The maximum amount of calories the recipe can have. (optional)
     * @param  float $min_fat The minimum amount of fat in grams the recipe must have. (optional)
     * @param  float $max_fat The maximum amount of fat in grams the recipe can have. (optional)
     * @param  float $min_alcohol The minimum amount of alcohol in grams the recipe must have. (optional)
     * @param  float $max_alcohol The maximum amount of alcohol in grams the recipe can have. (optional)
     * @param  float $min_caffeine The minimum amount of caffeine in milligrams the recipe must have. (optional)
     * @param  float $max_caffeine The maximum amount of caffeine in milligrams the recipe can have. (optional)
     * @param  float $min_copper The minimum amount of copper in milligrams the recipe must have. (optional)
     * @param  float $max_copper The maximum amount of copper in milligrams the recipe can have. (optional)
     * @param  float $min_calcium The minimum amount of calcium in milligrams the recipe must have. (optional)
     * @param  float $max_calcium The maximum amount of calcium in milligrams the recipe can have. (optional)
     * @param  float $min_choline The minimum amount of choline in milligrams the recipe must have. (optional)
     * @param  float $max_choline The maximum amount of choline in milligrams the recipe can have. (optional)
     * @param  float $min_cholesterol The minimum amount of cholesterol in milligrams the recipe must have. (optional)
     * @param  float $max_cholesterol The maximum amount of cholesterol in milligrams the recipe can have. (optional)
     * @param  float $min_fluoride The minimum amount of fluoride in milligrams the recipe must have. (optional)
     * @param  float $max_fluoride The maximum amount of fluoride in milligrams the recipe can have. (optional)
     * @param  float $min_saturated_fat The minimum amount of saturated fat in grams the recipe must have. (optional)
     * @param  float $max_saturated_fat The maximum amount of saturated fat in grams the recipe can have. (optional)
     * @param  float $min_vitamin_a The minimum amount of Vitamin A in IU the recipe must have. (optional)
     * @param  float $max_vitamin_a The maximum amount of Vitamin A in IU the recipe can have. (optional)
     * @param  float $min_vitamin_c The minimum amount of Vitamin C in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_c The maximum amount of Vitamin C in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_d The minimum amount of Vitamin D in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_d The maximum amount of Vitamin D in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_e The minimum amount of Vitamin E in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_e The maximum amount of Vitamin E in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_k The minimum amount of Vitamin K in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_k The maximum amount of Vitamin K in micrograms the recipe can have. (optional)
     * @param  float $min_vitamin_b1 The minimum amount of Vitamin B1 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b1 The maximum amount of Vitamin B1 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b2 The minimum amount of Vitamin B2 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b2 The maximum amount of Vitamin B2 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b5 The minimum amount of Vitamin B5 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b5 The maximum amount of Vitamin B5 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b3 The minimum amount of Vitamin B3 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b3 The maximum amount of Vitamin B3 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b6 The minimum amount of Vitamin B6 in milligrams the recipe must have. (optional)
     * @param  float $max_vitamin_b6 The maximum amount of Vitamin B6 in milligrams the recipe can have. (optional)
     * @param  float $min_vitamin_b12 The minimum amount of Vitamin B12 in micrograms the recipe must have. (optional)
     * @param  float $max_vitamin_b12 The maximum amount of Vitamin B12 in micrograms the recipe can have. (optional)
     * @param  float $min_fiber The minimum amount of fiber in grams the recipe must have. (optional)
     * @param  float $max_fiber The maximum amount of fiber in grams the recipe can have. (optional)
     * @param  float $min_folate The minimum amount of folate in micrograms the recipe must have. (optional)
     * @param  float $max_folate The maximum amount of folate in micrograms the recipe can have. (optional)
     * @param  float $min_folic_acid The minimum amount of folic acid in micrograms the recipe must have. (optional)
     * @param  float $max_folic_acid The maximum amount of folic acid in micrograms the recipe can have. (optional)
     * @param  float $min_iodine The minimum amount of iodine in micrograms the recipe must have. (optional)
     * @param  float $max_iodine The maximum amount of iodine in micrograms the recipe can have. (optional)
     * @param  float $min_iron The minimum amount of iron in milligrams the recipe must have. (optional)
     * @param  float $max_iron The maximum amount of iron in milligrams the recipe can have. (optional)
     * @param  float $min_magnesium The minimum amount of magnesium in milligrams the recipe must have. (optional)
     * @param  float $max_magnesium The maximum amount of magnesium in milligrams the recipe can have. (optional)
     * @param  float $min_manganese The minimum amount of manganese in milligrams the recipe must have. (optional)
     * @param  float $max_manganese The maximum amount of manganese in milligrams the recipe can have. (optional)
     * @param  float $min_phosphorus The minimum amount of phosphorus in milligrams the recipe must have. (optional)
     * @param  float $max_phosphorus The maximum amount of phosphorus in milligrams the recipe can have. (optional)
     * @param  float $min_potassium The minimum amount of potassium in milligrams the recipe must have. (optional)
     * @param  float $max_potassium The maximum amount of potassium in milligrams the recipe can have. (optional)
     * @param  float $min_selenium The minimum amount of selenium in micrograms the recipe must have. (optional)
     * @param  float $max_selenium The maximum amount of selenium in micrograms the recipe can have. (optional)
     * @param  float $min_sodium The minimum amount of sodium in milligrams the recipe must have. (optional)
     * @param  float $max_sodium The maximum amount of sodium in milligrams the recipe can have. (optional)
     * @param  float $min_sugar The minimum amount of sugar in grams the recipe must have. (optional)
     * @param  float $max_sugar The maximum amount of sugar in grams the recipe can have. (optional)
     * @param  float $min_zinc The minimum amount of zinc in milligrams the recipe must have. (optional)
     * @param  float $max_zinc The maximum amount of zinc in milligrams the recipe can have. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     * @param  bool $random If true, every request will give you a random set of recipes within the requested limits. (optional)
     * @param  bool $limit_license Whether the recipes should have an open license that allows display with proper attribution. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchRecipesByNutrientsRequest($min_carbs = null, $max_carbs = null, $min_protein = null, $max_protein = null, $min_calories = null, $max_calories = null, $min_fat = null, $max_fat = null, $min_alcohol = null, $max_alcohol = null, $min_caffeine = null, $max_caffeine = null, $min_copper = null, $max_copper = null, $min_calcium = null, $max_calcium = null, $min_choline = null, $max_choline = null, $min_cholesterol = null, $max_cholesterol = null, $min_fluoride = null, $max_fluoride = null, $min_saturated_fat = null, $max_saturated_fat = null, $min_vitamin_a = null, $max_vitamin_a = null, $min_vitamin_c = null, $max_vitamin_c = null, $min_vitamin_d = null, $max_vitamin_d = null, $min_vitamin_e = null, $max_vitamin_e = null, $min_vitamin_k = null, $max_vitamin_k = null, $min_vitamin_b1 = null, $max_vitamin_b1 = null, $min_vitamin_b2 = null, $max_vitamin_b2 = null, $min_vitamin_b5 = null, $max_vitamin_b5 = null, $min_vitamin_b3 = null, $max_vitamin_b3 = null, $min_vitamin_b6 = null, $max_vitamin_b6 = null, $min_vitamin_b12 = null, $max_vitamin_b12 = null, $min_fiber = null, $max_fiber = null, $min_folate = null, $max_folate = null, $min_folic_acid = null, $max_folic_acid = null, $min_iodine = null, $max_iodine = null, $min_iron = null, $max_iron = null, $min_magnesium = null, $max_magnesium = null, $min_manganese = null, $max_manganese = null, $min_phosphorus = null, $max_phosphorus = null, $min_potassium = null, $max_potassium = null, $min_selenium = null, $max_selenium = null, $min_sodium = null, $max_sodium = null, $min_sugar = null, $max_sugar = null, $min_zinc = null, $max_zinc = null, $offset = null, $number = 10, $random = null, $limit_license = true)
    {
        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipesByNutrients, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling RecipesApi.searchRecipesByNutrients, must be bigger than or equal to 0.');
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByNutrients, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling RecipesApi.searchRecipesByNutrients, must be bigger than or equal to 1.');
        }


        $resourcePath = '/recipes/findByNutrients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_carbs,
            'minCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_carbs,
            'maxCarbs', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_protein,
            'minProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_protein,
            'maxProtein', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calories,
            'minCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calories,
            'maxCalories', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fat,
            'minFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fat,
            'maxFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_alcohol,
            'minAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_alcohol,
            'maxAlcohol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_caffeine,
            'minCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_caffeine,
            'maxCaffeine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_copper,
            'minCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_copper,
            'maxCopper', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_calcium,
            'minCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_calcium,
            'maxCalcium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_choline,
            'minCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_choline,
            'maxCholine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_cholesterol,
            'minCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_cholesterol,
            'maxCholesterol', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fluoride,
            'minFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fluoride,
            'maxFluoride', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_saturated_fat,
            'minSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_saturated_fat,
            'maxSaturatedFat', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_a,
            'minVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_a,
            'maxVitaminA', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_c,
            'minVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_c,
            'maxVitaminC', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_d,
            'minVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_d,
            'maxVitaminD', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_e,
            'minVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_e,
            'maxVitaminE', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_k,
            'minVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_k,
            'maxVitaminK', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b1,
            'minVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b1,
            'maxVitaminB1', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b2,
            'minVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b2,
            'maxVitaminB2', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b5,
            'minVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b5,
            'maxVitaminB5', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b3,
            'minVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b3,
            'maxVitaminB3', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b6,
            'minVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b6,
            'maxVitaminB6', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_vitamin_b12,
            'minVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_vitamin_b12,
            'maxVitaminB12', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_fiber,
            'minFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_fiber,
            'maxFiber', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folate,
            'minFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folate,
            'maxFolate', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_folic_acid,
            'minFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_folic_acid,
            'maxFolicAcid', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iodine,
            'minIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iodine,
            'maxIodine', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_iron,
            'minIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_iron,
            'maxIron', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_magnesium,
            'minMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_magnesium,
            'maxMagnesium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_manganese,
            'minManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_manganese,
            'maxManganese', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_phosphorus,
            'minPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_phosphorus,
            'maxPhosphorus', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_potassium,
            'minPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_potassium,
            'maxPotassium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_selenium,
            'minSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_selenium,
            'maxSelenium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sodium,
            'minSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sodium,
            'maxSodium', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_sugar,
            'minSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_sugar,
            'maxSugar', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_zinc,
            'minZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_zinc,
            'maxZinc', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $random,
            'random', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit_license,
            'limitLicense', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation summarizeRecipe
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response
     */
    public function summarizeRecipe($id)
    {
        list($response) = $this->summarizeRecipeWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation summarizeRecipeWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function summarizeRecipeWithHttpInfo($id)
    {
        $request = $this->summarizeRecipeRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation summarizeRecipeAsync
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsync($id)
    {
        return $this->summarizeRecipeAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation summarizeRecipeAsyncWithHttpInfo
     *
     * Summarize Recipe
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function summarizeRecipeAsyncWithHttpInfo($id)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SummarizeRecipe200Response';
        $request = $this->summarizeRecipeRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'summarizeRecipe'
     *
     * @param  int $id The item&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function summarizeRecipeRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling summarizeRecipe'
            );
        }

        $resourcePath = '/recipes/{id}/summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeEquipment
     *
     * Equipment Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeEquipment($content_type = null, $accept = null)
    {
        list($response) = $this->visualizeEquipmentWithHttpInfo($content_type, $accept);
        return $response;
    }

    /**
     * Operation visualizeEquipmentWithHttpInfo
     *
     * Equipment Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeEquipmentWithHttpInfo($content_type = null, $accept = null)
    {
        $request = $this->visualizeEquipmentRequest($content_type, $accept);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeEquipmentAsync
     *
     * Equipment Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsync($content_type = null, $accept = null)
    {
        return $this->visualizeEquipmentAsyncWithHttpInfo($content_type, $accept)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeEquipmentAsyncWithHttpInfo
     *
     * Equipment Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeEquipmentAsyncWithHttpInfo($content_type = null, $accept = null)
    {
        $returnType = 'string';
        $request = $this->visualizeEquipmentRequest($content_type, $accept);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeEquipment'
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeEquipmentRequest($content_type = null, $accept = null)
    {

        $resourcePath = '/recipes/visualizeEquipment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizePriceBreakdown
     *
     * Price Breakdown Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizePriceBreakdown($content_type = null, $accept = null, $language = null)
    {
        list($response) = $this->visualizePriceBreakdownWithHttpInfo($content_type, $accept, $language);
        return $response;
    }

    /**
     * Operation visualizePriceBreakdownWithHttpInfo
     *
     * Price Breakdown Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizePriceBreakdownWithHttpInfo($content_type = null, $accept = null, $language = null)
    {
        $request = $this->visualizePriceBreakdownRequest($content_type, $accept, $language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizePriceBreakdownAsync
     *
     * Price Breakdown Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsync($content_type = null, $accept = null, $language = null)
    {
        return $this->visualizePriceBreakdownAsyncWithHttpInfo($content_type, $accept, $language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizePriceBreakdownAsyncWithHttpInfo
     *
     * Price Breakdown Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizePriceBreakdownAsyncWithHttpInfo($content_type = null, $accept = null, $language = null)
    {
        $returnType = 'string';
        $request = $this->visualizePriceBreakdownRequest($content_type, $accept, $language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizePriceBreakdown'
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizePriceBreakdownRequest($content_type = null, $accept = null, $language = null)
    {

        $resourcePath = '/recipes/visualizePriceEstimator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeEquipmentByID
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeEquipmentByID($id, $default_css = true)
    {
        list($response) = $this->visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipeEquipmentByIDWithHttpInfo
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeEquipmentByIDWithHttpInfo($id, $default_css = true)
    {
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsync
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsync($id, $default_css = true)
    {
        return $this->visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeEquipmentByIDAsyncWithHttpInfo
     *
     * Equipment by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeEquipmentByIDAsyncWithHttpInfo($id, $default_css = true)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeEquipmentByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeEquipmentByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeEquipmentByIDRequest($id, $default_css = true)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeEquipmentByID'
            );
        }

        $resourcePath = '/recipes/{id}/equipmentWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeIngredientsByID
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeIngredientsByID($id, $default_css = true, $measure = null)
    {
        list($response) = $this->visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css, $measure);
        return $response;
    }

    /**
     * Operation visualizeRecipeIngredientsByIDWithHttpInfo
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeIngredientsByIDWithHttpInfo($id, $default_css = true, $measure = null)
    {
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css, $measure);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsync
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsync($id, $default_css = true, $measure = null)
    {
        return $this->visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css, $measure)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeIngredientsByIDAsyncWithHttpInfo
     *
     * Ingredients by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeIngredientsByIDAsyncWithHttpInfo($id, $default_css = true, $measure = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeIngredientsByIDRequest($id, $default_css, $measure);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeIngredientsByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $measure Whether the the measures should be &#39;us&#39; or &#39;metric&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeIngredientsByIDRequest($id, $default_css = true, $measure = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeIngredientsByID'
            );
        }

        $resourcePath = '/recipes/{id}/ingredientWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $measure,
            'measure', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutrition
     *
     * Recipe Nutrition Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutrition($content_type = null, $accept = null, $language = null)
    {
        list($response) = $this->visualizeRecipeNutritionWithHttpInfo($content_type, $accept, $language);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionWithHttpInfo
     *
     * Recipe Nutrition Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionWithHttpInfo($content_type = null, $accept = null, $language = null)
    {
        $request = $this->visualizeRecipeNutritionRequest($content_type, $accept, $language);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionAsync
     *
     * Recipe Nutrition Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsync($content_type = null, $accept = null, $language = null)
    {
        return $this->visualizeRecipeNutritionAsyncWithHttpInfo($content_type, $accept, $language)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionAsyncWithHttpInfo
     *
     * Recipe Nutrition Widget
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionAsyncWithHttpInfo($content_type = null, $accept = null, $language = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionRequest($content_type, $accept, $language);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutrition'
     *
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeNutritionRequest($content_type = null, $accept = null, $language = null)
    {

        $resourcePath = '/recipes/visualizeNutrition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeNutritionByID
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeNutritionByID($id, $default_css = true, $accept = null)
    {
        list($response) = $this->visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css, $accept);
        return $response;
    }

    /**
     * Operation visualizeRecipeNutritionByIDWithHttpInfo
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeNutritionByIDWithHttpInfo($id, $default_css = true, $accept = null)
    {
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css, $accept);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsync
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsync($id, $default_css = true, $accept = null)
    {
        return $this->visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css, $accept)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeNutritionByIDAsyncWithHttpInfo
     *
     * Recipe Nutrition by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeNutritionByIDAsyncWithHttpInfo($id, $default_css = true, $accept = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeNutritionByIDRequest($id, $default_css, $accept);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeNutritionByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     * @param  string $accept Accept header. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeNutritionByIDRequest($id, $default_css = true, $accept = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeNutritionByID'
            );
        }

        $resourcePath = '/recipes/{id}/nutritionWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByID
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipePriceBreakdownByID($id, $default_css = true)
    {
        list($response) = $this->visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css);
        return $response;
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDWithHttpInfo
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipePriceBreakdownByIDWithHttpInfo($id, $default_css = true)
    {
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsync
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsync($id, $default_css = true)
    {
        return $this->visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo
     *
     * Price Breakdown by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipePriceBreakdownByIDAsyncWithHttpInfo($id, $default_css = true)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipePriceBreakdownByIDRequest($id, $default_css);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipePriceBreakdownByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $default_css Whether the default CSS should be added to the response. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipePriceBreakdownByIDRequest($id, $default_css = true)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipePriceBreakdownByID'
            );
        }

        $resourcePath = '/recipes/{id}/priceBreakdownWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default_css,
            'defaultCss', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeTaste
     *
     * Recipe Taste Widget
     *
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeTaste($language = null, $content_type = null, $accept = null, $normalize = null, $rgb = null)
    {
        list($response) = $this->visualizeRecipeTasteWithHttpInfo($language, $content_type, $accept, $normalize, $rgb);
        return $response;
    }

    /**
     * Operation visualizeRecipeTasteWithHttpInfo
     *
     * Recipe Taste Widget
     *
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeTasteWithHttpInfo($language = null, $content_type = null, $accept = null, $normalize = null, $rgb = null)
    {
        $request = $this->visualizeRecipeTasteRequest($language, $content_type, $accept, $normalize, $rgb);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeTasteAsync
     *
     * Recipe Taste Widget
     *
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteAsync($language = null, $content_type = null, $accept = null, $normalize = null, $rgb = null)
    {
        return $this->visualizeRecipeTasteAsyncWithHttpInfo($language, $content_type, $accept, $normalize, $rgb)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeTasteAsyncWithHttpInfo
     *
     * Recipe Taste Widget
     *
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteAsyncWithHttpInfo($language = null, $content_type = null, $accept = null, $normalize = null, $rgb = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeTasteRequest($language, $content_type, $accept, $normalize, $rgb);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeTaste'
     *
     * @param  string $language The language of the input. Either &#39;en&#39; or &#39;de&#39;. (optional)
     * @param  string $content_type The content type. (optional)
     * @param  string $accept Accept header. (optional)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeTasteRequest($language = null, $content_type = null, $accept = null, $normalize = null, $rgb = null)
    {

        $resourcePath = '/recipes/visualizeTaste';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $language,
            'language', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rgb,
            'rgb', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation visualizeRecipeTasteByID
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function visualizeRecipeTasteByID($id, $normalize = true, $rgb = null)
    {
        list($response) = $this->visualizeRecipeTasteByIDWithHttpInfo($id, $normalize, $rgb);
        return $response;
    }

    /**
     * Operation visualizeRecipeTasteByIDWithHttpInfo
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function visualizeRecipeTasteByIDWithHttpInfo($id, $normalize = true, $rgb = null)
    {
        $request = $this->visualizeRecipeTasteByIDRequest($id, $normalize, $rgb);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation visualizeRecipeTasteByIDAsync
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteByIDAsync($id, $normalize = true, $rgb = null)
    {
        return $this->visualizeRecipeTasteByIDAsyncWithHttpInfo($id, $normalize, $rgb)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation visualizeRecipeTasteByIDAsyncWithHttpInfo
     *
     * Recipe Taste by ID Widget
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function visualizeRecipeTasteByIDAsyncWithHttpInfo($id, $normalize = true, $rgb = null)
    {
        $returnType = 'string';
        $request = $this->visualizeRecipeTasteByIDRequest($id, $normalize, $rgb);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'visualizeRecipeTasteByID'
     *
     * @param  int $id The item&#39;s id. (required)
     * @param  bool $normalize Whether to normalize to the strongest taste. (optional, default to true)
     * @param  string $rgb Red, green, blue values for the chart color. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function visualizeRecipeTasteByIDRequest($id, $normalize = true, $rgb = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling visualizeRecipeTasteByID'
            );
        }

        $resourcePath = '/recipes/{id}/tasteWidget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $normalize,
            'normalize', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rgb,
            'rgb', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
