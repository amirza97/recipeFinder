<?php
/**
 * MiscApi
 * PHP version 7.4
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * spoonacular API
 *
 * The spoonacular Nutrition, Recipe, and Food API allows you to access over thousands of recipes, thousands of ingredients, 800,000 food products, over 100,000 menu items, and restaurants. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.
 *
 * The version of the OpenAPI document: 1.1
 * Contact: mail@spoonacular.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.spoonacular.client\com.spoonacular;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.spoonacular.client\ApiException;
use com.spoonacular.client\Configuration;
use com.spoonacular.client\HeaderSelector;
use com.spoonacular.client\ObjectSerializer;

/**
 * MiscApi Class Doc Comment
 *
 * @category Class
 * @package  com.spoonacular.client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class MiscApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation detectFoodInText
     *
     * Detect Food in Text
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response
     */
    public function detectFoodInText($content_type = null)
    {
        list($response) = $this->detectFoodInTextWithHttpInfo($content_type);
        return $response;
    }

    /**
     * Operation detectFoodInTextWithHttpInfo
     *
     * Detect Food in Text
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function detectFoodInTextWithHttpInfo($content_type = null)
    {
        $request = $this->detectFoodInTextRequest($content_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation detectFoodInTextAsync
     *
     * Detect Food in Text
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectFoodInTextAsync($content_type = null)
    {
        return $this->detectFoodInTextAsyncWithHttpInfo($content_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation detectFoodInTextAsyncWithHttpInfo
     *
     * Detect Food in Text
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function detectFoodInTextAsyncWithHttpInfo($content_type = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\DetectFoodInText200Response';
        $request = $this->detectFoodInTextRequest($content_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'detectFoodInText'
     *
     * @param  string $content_type The content type. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function detectFoodInTextRequest($content_type = null)
    {

        $resourcePath = '/food/detect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getARandomFoodJoke
     *
     * Random Food Joke
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response
     */
    public function getARandomFoodJoke()
    {
        list($response) = $this->getARandomFoodJokeWithHttpInfo();
        return $response;
    }

    /**
     * Operation getARandomFoodJokeWithHttpInfo
     *
     * Random Food Joke
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getARandomFoodJokeWithHttpInfo()
    {
        $request = $this->getARandomFoodJokeRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getARandomFoodJokeAsync
     *
     * Random Food Joke
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARandomFoodJokeAsync()
    {
        return $this->getARandomFoodJokeAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getARandomFoodJokeAsyncWithHttpInfo
     *
     * Random Food Joke
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getARandomFoodJokeAsyncWithHttpInfo()
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetARandomFoodJoke200Response';
        $request = $this->getARandomFoodJokeRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getARandomFoodJoke'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getARandomFoodJokeRequest()
    {

        $resourcePath = '/food/jokes/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationSuggests
     *
     * Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response
     */
    public function getConversationSuggests($query, $number = null)
    {
        list($response) = $this->getConversationSuggestsWithHttpInfo($query, $number);
        return $response;
    }

    /**
     * Operation getConversationSuggestsWithHttpInfo
     *
     * Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationSuggestsWithHttpInfo($query, $number = null)
    {
        $request = $this->getConversationSuggestsRequest($query, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationSuggestsAsync
     *
     * Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationSuggestsAsync($query, $number = null)
    {
        return $this->getConversationSuggestsAsyncWithHttpInfo($query, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationSuggestsAsyncWithHttpInfo
     *
     * Conversation Suggests
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationSuggestsAsyncWithHttpInfo($query, $number = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetConversationSuggests200Response';
        $request = $this->getConversationSuggestsRequest($query, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationSuggests'
     *
     * @param  string $query A (partial) query from the user. The endpoint will return if it matches topics it can talk about. (required)
     * @param  float $number The number of suggestions to return (between 1 and 25). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConversationSuggestsRequest($query, $number = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling getConversationSuggests'
            );
        }

        $resourcePath = '/food/converse/suggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRandomFoodTrivia
     *
     * Random Food Trivia
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response
     */
    public function getRandomFoodTrivia()
    {
        list($response) = $this->getRandomFoodTriviaWithHttpInfo();
        return $response;
    }

    /**
     * Operation getRandomFoodTriviaWithHttpInfo
     *
     * Random Food Trivia
     *
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRandomFoodTriviaWithHttpInfo()
    {
        $request = $this->getRandomFoodTriviaRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRandomFoodTriviaAsync
     *
     * Random Food Trivia
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomFoodTriviaAsync()
    {
        return $this->getRandomFoodTriviaAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRandomFoodTriviaAsyncWithHttpInfo
     *
     * Random Food Trivia
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRandomFoodTriviaAsyncWithHttpInfo()
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\GetRandomFoodTrivia200Response';
        $request = $this->getRandomFoodTriviaRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRandomFoodTrivia'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRandomFoodTriviaRequest()
    {

        $resourcePath = '/food/trivia/random';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageAnalysisByURL
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response
     */
    public function imageAnalysisByURL($image_url)
    {
        list($response) = $this->imageAnalysisByURLWithHttpInfo($image_url);
        return $response;
    }

    /**
     * Operation imageAnalysisByURLWithHttpInfo
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageAnalysisByURLWithHttpInfo($image_url)
    {
        $request = $this->imageAnalysisByURLRequest($image_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageAnalysisByURLAsync
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAnalysisByURLAsync($image_url)
    {
        return $this->imageAnalysisByURLAsyncWithHttpInfo($image_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageAnalysisByURLAsyncWithHttpInfo
     *
     * Image Analysis by URL
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageAnalysisByURLAsyncWithHttpInfo($image_url)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ImageAnalysisByURL200Response';
        $request = $this->imageAnalysisByURLRequest($image_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageAnalysisByURL'
     *
     * @param  string $image_url The URL of the image to be analyzed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function imageAnalysisByURLRequest($image_url)
    {
        // verify the required parameter 'image_url' is set
        if ($image_url === null || (is_array($image_url) && count($image_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_url when calling imageAnalysisByURL'
            );
        }

        $resourcePath = '/food/images/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_url,
            'imageUrl', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation imageClassificationByURL
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response
     */
    public function imageClassificationByURL($image_url)
    {
        list($response) = $this->imageClassificationByURLWithHttpInfo($image_url);
        return $response;
    }

    /**
     * Operation imageClassificationByURLWithHttpInfo
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function imageClassificationByURLWithHttpInfo($image_url)
    {
        $request = $this->imageClassificationByURLRequest($image_url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation imageClassificationByURLAsync
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageClassificationByURLAsync($image_url)
    {
        return $this->imageClassificationByURLAsyncWithHttpInfo($image_url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation imageClassificationByURLAsyncWithHttpInfo
     *
     * Image Classification by URL
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function imageClassificationByURLAsyncWithHttpInfo($image_url)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\ImageClassificationByURL200Response';
        $request = $this->imageClassificationByURLRequest($image_url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'imageClassificationByURL'
     *
     * @param  string $image_url The URL of the image to be classified. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function imageClassificationByURLRequest($image_url)
    {
        // verify the required parameter 'image_url' is set
        if ($image_url === null || (is_array($image_url) && count($image_url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image_url when calling imageClassificationByURL'
            );
        }

        $resourcePath = '/food/images/classify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $image_url,
            'imageUrl', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchAllFood
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response
     */
    public function searchAllFood($query, $offset = null, $number = 10)
    {
        list($response) = $this->searchAllFoodWithHttpInfo($query, $offset, $number);
        return $response;
    }

    /**
     * Operation searchAllFoodWithHttpInfo
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchAllFoodWithHttpInfo($query, $offset = null, $number = 10)
    {
        $request = $this->searchAllFoodRequest($query, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAllFoodAsync
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAllFoodAsync($query, $offset = null, $number = 10)
    {
        return $this->searchAllFoodAsyncWithHttpInfo($query, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAllFoodAsyncWithHttpInfo
     *
     * Search All Food
     *
     * @param  string $query The search query. (required)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAllFoodAsyncWithHttpInfo($query, $offset = null, $number = 10)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchAllFood200Response';
        $request = $this->searchAllFoodRequest($query, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchAllFood'
     *
     * @param  string $query The search query. (required)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchAllFoodRequest($query, $offset = null, $number = 10)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchAllFood'
            );
        }
        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MiscApi.searchAllFood, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MiscApi.searchAllFood, must be bigger than or equal to 0.');
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MiscApi.searchAllFood, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MiscApi.searchAllFood, must be bigger than or equal to 1.');
        }


        $resourcePath = '/food/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchCustomFoods
     *
     * Search Custom Foods
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response
     */
    public function searchCustomFoods($username, $hash, $query = null, $offset = null, $number = 10)
    {
        list($response) = $this->searchCustomFoodsWithHttpInfo($username, $hash, $query, $offset, $number);
        return $response;
    }

    /**
     * Operation searchCustomFoodsWithHttpInfo
     *
     * Search Custom Foods
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchCustomFoodsWithHttpInfo($username, $hash, $query = null, $offset = null, $number = 10)
    {
        $request = $this->searchCustomFoodsRequest($username, $hash, $query, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchCustomFoodsAsync
     *
     * Search Custom Foods
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCustomFoodsAsync($username, $hash, $query = null, $offset = null, $number = 10)
    {
        return $this->searchCustomFoodsAsyncWithHttpInfo($username, $hash, $query, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchCustomFoodsAsyncWithHttpInfo
     *
     * Search Custom Foods
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchCustomFoodsAsyncWithHttpInfo($username, $hash, $query = null, $offset = null, $number = 10)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchCustomFoods200Response';
        $request = $this->searchCustomFoodsRequest($username, $hash, $query, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchCustomFoods'
     *
     * @param  string $username The username. (required)
     * @param  string $hash The private hash for the username. (required)
     * @param  string $query The (natural language) search query. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchCustomFoodsRequest($username, $hash, $query = null, $offset = null, $number = 10)
    {
        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling searchCustomFoods'
            );
        }
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling searchCustomFoods'
            );
        }
        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MiscApi.searchCustomFoods, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MiscApi.searchCustomFoods, must be bigger than or equal to 0.');
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MiscApi.searchCustomFoods, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MiscApi.searchCustomFoods, must be bigger than or equal to 1.');
        }


        $resourcePath = '/food/customFoods/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchFoodVideos
     *
     * Search Food Videos
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response
     */
    public function searchFoodVideos($query = null, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = 10)
    {
        list($response) = $this->searchFoodVideosWithHttpInfo($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);
        return $response;
    }

    /**
     * Operation searchFoodVideosWithHttpInfo
     *
     * Search Food Videos
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchFoodVideosWithHttpInfo($query = null, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = 10)
    {
        $request = $this->searchFoodVideosRequest($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchFoodVideosAsync
     *
     * Search Food Videos
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFoodVideosAsync($query = null, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = 10)
    {
        return $this->searchFoodVideosAsyncWithHttpInfo($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchFoodVideosAsyncWithHttpInfo
     *
     * Search Food Videos
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchFoodVideosAsyncWithHttpInfo($query = null, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = 10)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchFoodVideos200Response';
        $request = $this->searchFoodVideosRequest($query, $type, $cuisine, $diet, $include_ingredients, $exclude_ingredients, $min_length, $max_length, $offset, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchFoodVideos'
     *
     * @param  string $query The (natural language) search query. (optional)
     * @param  string $type The type of the recipes. See a full list of supported meal types. (optional)
     * @param  string $cuisine The cuisine(s) of the recipes. One or more, comma separated. See a full list of supported cuisines. (optional)
     * @param  string $diet The diet for which the recipes must be suitable. See a full list of supported diets. (optional)
     * @param  string $include_ingredients A comma-separated list of ingredients that the recipes should contain. (optional)
     * @param  string $exclude_ingredients A comma-separated list of ingredients or ingredient types that the recipes must not contain. (optional)
     * @param  float $min_length Minimum video length in seconds. (optional)
     * @param  float $max_length Maximum video length in seconds. (optional)
     * @param  int $offset The number of results to skip (between 0 and 900). (optional)
     * @param  int $number The maximum number of items to return (between 1 and 100). Defaults to 10. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchFoodVideosRequest($query = null, $type = null, $cuisine = null, $diet = null, $include_ingredients = null, $exclude_ingredients = null, $min_length = null, $max_length = null, $offset = null, $number = 10)
    {
        if ($offset !== null && $offset > 900) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MiscApi.searchFoodVideos, must be smaller than or equal to 900.');
        }
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling MiscApi.searchFoodVideos, must be bigger than or equal to 0.');
        }

        if ($number !== null && $number > 100) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MiscApi.searchFoodVideos, must be smaller than or equal to 100.');
        }
        if ($number !== null && $number < 1) {
            throw new \InvalidArgumentException('invalid value for "$number" when calling MiscApi.searchFoodVideos, must be bigger than or equal to 1.');
        }


        $resourcePath = '/food/videos/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cuisine,
            'cuisine', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $diet,
            'diet', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_ingredients,
            'includeIngredients', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_ingredients,
            'excludeIngredients', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_length,
            'minLength', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_length,
            'maxLength', // param base name
            'number', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number,
            'number', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchSiteContent
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response
     */
    public function searchSiteContent($query)
    {
        list($response) = $this->searchSiteContentWithHttpInfo($query);
        return $response;
    }

    /**
     * Operation searchSiteContentWithHttpInfo
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchSiteContentWithHttpInfo($query)
    {
        $request = $this->searchSiteContentRequest($query);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchSiteContentAsync
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSiteContentAsync($query)
    {
        return $this->searchSiteContentAsyncWithHttpInfo($query)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchSiteContentAsyncWithHttpInfo
     *
     * Search Site Content
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchSiteContentAsyncWithHttpInfo($query)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\SearchSiteContent200Response';
        $request = $this->searchSiteContentRequest($query);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchSiteContent'
     *
     * @param  string $query The query to search for. You can also use partial queries such as \&quot;spagh\&quot; to already find spaghetti recipes, articles, grocery products, and other content. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchSiteContentRequest($query)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling searchSiteContent'
            );
        }

        $resourcePath = '/food/site/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation talkToChatbot
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response
     */
    public function talkToChatbot($text, $context_id = null)
    {
        list($response) = $this->talkToChatbotWithHttpInfo($text, $context_id);
        return $response;
    }

    /**
     * Operation talkToChatbotWithHttpInfo
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \com.spoonacular.client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function talkToChatbotWithHttpInfo($text, $context_id = null)
    {
        $request = $this->talkToChatbotRequest($text, $context_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation talkToChatbotAsync
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function talkToChatbotAsync($text, $context_id = null)
    {
        return $this->talkToChatbotAsyncWithHttpInfo($text, $context_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation talkToChatbotAsyncWithHttpInfo
     *
     * Talk to Chatbot
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function talkToChatbotAsyncWithHttpInfo($text, $context_id = null)
    {
        $returnType = '\com.spoonacular.client\com.spoonacular.client.model\TalkToChatbot200Response';
        $request = $this->talkToChatbotRequest($text, $context_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'talkToChatbot'
     *
     * @param  string $text The request / question / answer from the user to the chatbot. (required)
     * @param  string $context_id An arbitrary globally unique id for your conversation. The conversation can contain states so you should pass your context id if you want the bot to be able to remember the conversation. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function talkToChatbotRequest($text, $context_id = null)
    {
        // verify the required parameter 'text' is set
        if ($text === null || (is_array($text) && count($text) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $text when calling talkToChatbot'
            );
        }

        $resourcePath = '/food/converse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $text,
            'text', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context_id,
            'contextId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
